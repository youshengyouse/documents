---
title: 基础教程第04课
---

## 如何渲染.mdx 或.md 文件

- 参考： `https://nextjs.org/docs/app/guides/mdx`
- 测试：默认不渲染 mdx 文件，删除 `/src/app/page.tsx`和`not-found.tsx`文件，新增 `/src/app/page.mdx`文件,报 404 错误

<Tabs
  items={[
    '第1步：安装4个依赖',
    '第2步：文件处理',
    '@next/mdx',
    '@mdx-js/loader',
    '@mdx-js/react',
    '@types/mdx',
  ]}
>
  <Tab value="第1步：安装4个依赖">
    ```bash
    pnpm add @next/mdx @mdx-js/loader @mdx-js/react @types/mdx 
    ```

**工作流程**：
`@next/mdx` 通过 Next.js 配置集成 MDX，
调用 `@mdx-js/loader` 完成编译，
依赖 `@mdx-js/react` 实现组件交互，
并通过 `@types/mdx` 提供类型安全。

**典型配置**：在 Next.js 项目中，四者通常需同时安装以覆盖编译、渲染和类型支持。

如需更详细的插件配置或高级用法（如自定义 remark/rehype 插件），可进一步参考 Next.js 和 MDX 官方文档

  </Tab>
    <Tab value="第2步：文件处理">
修改
```ts filename="next.config.ts"
import type { NextConfig } from "next";
import createMDX from "@next/mdx";

const nextConfig: NextConfig = {
pageExtensions: ["js", "jsx", "md", "mdx", "ts", "tsx"], // /app/src/page.md 也行
};
const withMDX = createMDX({
extension: /\.(md|mdx)$/,
});
export default withMDX(nextConfig);

````
新建
```ts filename="@/mdx-components.tsx"
import type { MDXComponents } from 'mdx/types'
export function useMDXComponents(components: MDXComponents): MDXComponents {
  return {
    ...components,
  }
}
````

</Tab>
  <Tab value="@next/mdx">
  **@next/mdx**

**作用**：  
这是 Next.js 官方提供的 MDX 集成工具包，用于在 Next.js 项目中无缝支持 MDX 文件。它允许将 `.mdx` 文件直接作为页面路由（如 `/pages` 或 `/app` 目录下的文件），并通过 Next.js 的构建系统将 MDX 编译为 React 组件。

**关键功能**：
配置 Next.js 以识别 `.mdx` 文件扩展名（通过 `next.config.js` 修改 `pageExtensions`）。

支持在 MDX 中直接导入 React 组件并渲染。

与 Next.js 的服务端组件（App Router）和静态生成（SSG）兼容。

**引用场景**：

     例如，在 `next.config.js` 中添加 `@next/mdx` 配置后，可直接创建 `pages/about.mdx` 作为路由页面。
      </Tab>

<Tab value="@mdx-js/loader">
 **@mdx-js/loader**

**作用**：  
MDX 的 Webpack 加载器（Loader），负责将 MDX 文件编译为 JavaScript/React 代码。它是底层工具链的一部分，用于解析 MDX 语法（如 JSX 和 Markdown 混合内容）并生成可执行的组件代码。

**关键功能**：

在构建阶段将 `.mdx` 文件转换为 React 组件。

支持通过 Webpack 配置自定义插件（如添加语法高亮、Frontmatter 解析等）。

     **引用场景**：
     当使用 Next.js 时，`@next/mdx` 内部依赖此包处理文件编译。
    </Tab>

  <Tab value="@mdx-js/react">
  **@mdx-js/react**

**作用**：  
提供 React 上下文（Context）支持，用于在 MDX 文件中使用自定义的 React 组件。通过 `MDXProvider` 组件，可以全局替换 MDX 中的原生 HTML 标签（如 `<h1>` 替换为自定义的 `<Heading>` 组件）。

**关键功能**：

定义全局 MDX 组件映射（如 `components` 对象）。

支持动态传递 props 到 MDX 文件中使用的组件。  
 **引用场景**：  
 在 `mdx-components.tsx` 中定义 `useMDXComponents` 函数，统一管理 MDX 中的组件样式和逻辑。

</Tab>

  <Tab value="@types/mdx">
  **@types/mdx**

**作用**：  
提供 MDX 文件的 TypeScript 类型声明，解决 TypeScript 项目中导入 `.mdx` 文件时的类型检查问题（如识别 MDX 默认导出的 React 组件类型）。

**关键功能**：

声明 `.mdx` 文件模块类型为 React 组件。

支持在 MDX 中导出 Frontmatter 或其他自定义数据的类型推导。  
 **引用场景**：  
 在 TypeScript 项目中，导入 MDX 文件时会自动识别为 `React.ComponentType` 类型。

</Tab>

</Tabs>

---

## 准备.mdx 文件

拷贝 `src/es6-docs`下面所有.mdx 文件到 `src/app/(docs)/es6/` 目录下，然后执行

```bash filename="src/app/(docs)/es6/"
# 遍历当前目录下的所有文件
for f in *; do
    [ -f "$f" ] &&            # 检查$f是否为普通文件
    mkdir -p "${f%.*}" &&    # 创建以$f文件名（不含扩展名）命名的目录
    mv "$f" "${f%.*}/page.mdx"  # 将文件移动到新目录并重命名为page.mdx
done
# for f in *; do [ -f "$f" ] && mkdir -p "${f%.*}" && mv "$f" "${f%.*}/page.mdx";done
```

为了演示，给 docs 建布局文件

```tsx filename="src/app/(docs)/es6/layout.tsx"
import React from "react";

export default function layout({ children }: { children: React.ReactNode }) {
  return (
    <div id="docs" className="rounded-xl border-10 border-amber-400 p-4">
      {children}
    </div>
  );
}
```

在浏览器中输入 `http://localhost:3003/es6/blog` ，读取了 blog.mdx 内容

提示：如果是.md 文件，如 `src/app/(docs)/es6/blog.md`，请关闭 turbopack,修改 package.json 中的"dev": `"next dev --turbopack",`，删除`--turbopack`

## 远程读取 mdx 文件

> https://github.com/hashicorp/next-mdx-remote

```bash
pnpm add next-mdx-remote

```

修改 next.config.ts

```ts filename="next.config.ts"
import type { NextConfig } from "next";
// import createMDX from '@next/mdx'

const nextConfig: NextConfig = {
  transpilePackages: ["next-mdx-remote"], //[!code ++]
  //   pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'], // /app/src/page.md也行
};
// const withMDX = createMDX({
//   extension: /\.(md|mdx)$/,
// })
// export default withMDX(nextConfig)
export default nextConfig;
```

说明：`src/mdx-components.tsx`文件也可以删除

添加文件 `src/app/(docs)/es6/[es6slug]/page.tsx`,并删除前面准备的.mdx 文件

```tsx filename="src/app/(docs)/es6/[es6slug]/page.tsx"
import React from "react";
import { promises as fs } from "fs";
import { join } from "path";

export default async function page() {
  const content = await fs.readFile(
    join(process.cwd(), "src", "es6-docs", "blog.mdx"),
    "utf-8"
  );
  console.log(content);
  return <div>{content}</div>;
}
```

```ts
import React from "react";
import { promises as fs } from "fs";
import { join } from "path";
import { MDXRemote } from "next-mdx-remote/rsc";

export default async function page() {
  const content = await fs.readFile(
    join(process.cwd(), "src", "es6-docs", "blog.mdx"),
    "utf-8"
  );
  console.log(content);
  return (
    <div>
      <MDXRemote source={content} />
    </div>
  );
}
```

报错：

```
Error: Expected component `Checklist` to be defined: you likely forgot to import, pass, or provide it.
It’s referenced in your code at `56:1-75:6`
```

这是因为 mdx 文件中用到了 Checklist 组件，`<MDXRemote source={content} component />`中没有指定

```
import React from "react";
import { promises as fs } from "fs";
import { join } from "path";
import { MDXRemote } from "next-mdx-remote/rsc";

import ProjectHeader from "@/components/ProjectHeader";
import ProjectContent from "@/components/ProjectContent";
import ProjectSidebar from "@/components/ProjectSidebar";
import Checklist from "@/components/Checklist";
import LoginRequired from "@/components/LoginRequired";
import Container from "@/components/Container";

export default async function page() {
  const content = await fs.readFile(
    join(process.cwd(), "src", "es6-docs", "blog.mdx"),
    "utf-8",
  );
  return (
    <div>
      <MDXRemote
        source={content}
        components={{
          ProjectHeader,
          ProjectContent,
          ProjectSidebar,
          Checklist,
          LoginRequired,
          Container,
        }}
      />
    </div>
  );
}

```

```
import { MDXRemote, compileMDX } from "next-mdx-remote/rsc";
  const data = await compileMDX({
    source: content,
    options: {
      parseFrontmatter: true,
    },
    components: {
      ProjectHeader,
      ProjectContent,
      ProjectSidebar,
      Checklist,
      LoginRequired,
      Container,
    },
  });
  console.log("解析内容如下:", data);

解析内容如下: {
  content: {
    '$$typeof': Symbol(react.transitional.element),
    type: [Function: MDXContent],
    key: null,
    props: { components: {} },
    _owner: {
      name: 'page',
      env: 'Server',
      key: null,
      owner: null,
      stack: [],
      props: [Object],
      debugStack: [Error: react-stack-top-frame],
      debugTask: [Object]
    },
    _store: {}
  },
  frontmatter: {
    title: 'Blog',
    layout: 'project',
    topic: 'Personal & Portfolio',
    description: 'Create a blog that you can use to share your career experiences and projects.'
  }
}
```

多光标拷贝小技巧
双击第 1 个 from,按 5 次 `Ctrl+D`,这样 6 个 from 都被选中，向左箭头移动 6 个光标到 6 个类的后面，再按 Shift+Home 键,光标跳到了行首，`Shift+向右箭头`移到 6 个类的前面，按 Ctrl+C，就将这 6 个类复制到剪切板

### metadata

```tsx
// export const metadata = {
//   title: "标题123",
//   description: "2222222",
// };
export async function generateMetadata() {
  const content = await fs.readFile(
    join(process.cwd(), "src", "es6-docs", "博客.mdx"),
    "utf-8"
  );
  const { frontmatter } = await compileMDX<{
    title: string;
    description: string;
  }>({
    source: content,
    options: {
      parseFrontmatter: true,
    },
  });
  return {
    title: `${frontmatter.title}2025`,
    description: `${frontmatter.description}`,
  };
}
```

### 通用

```tsx
import React from "react";
import { promises as fs } from "fs";
import { join } from "path";
import { MDXRemote, compileMDX } from "next-mdx-remote/rsc";

import ProjectHeader from "@/components/ProjectHeader";
import ProjectContent from "@/components/ProjectContent";
import ProjectSidebar from "@/components/ProjectSidebar";
import Checklist from "@/components/Checklist";
import LoginRequired from "@/components/LoginRequired";
import Container from "@/components/Container";

// export const metadata = {
//   title: "标题123",
//   description: "2222222",
// };
export async function generateMetadata() {
  const content = await fs.readFile(
    join(process.cwd(), "src", "es6-docs", "博客.mdx"),
    "utf-8"
  );
  const { frontmatter } = await compileMDX<{
    title: string;
    description: string;
  }>({
    source: content,
    options: {
      parseFrontmatter: true,
    },
  });
  return {
    title: `${frontmatter.title}|2025`,
    description: `${frontmatter.description}`,
  };
}

export default async function page({
  params,
}: {
  params: { es6slug: string };
}) {
  const content = await fs.readFile(
    join(
      process.cwd(),
      "src",
      "es6-docs",
      `${decodeURIComponent(params.es6slug)}.mdx`
    ),
    "utf-8"
  );
  const data = await compileMDX<{ topic: string; description: string }>({
    source: content,
    options: {
      parseFrontmatter: true,
    },
    components: {
      ProjectHeader,
      ProjectContent,
      ProjectSidebar,
      Checklist,
      LoginRequired,
      Container,
    },
  });
  console.log("解析内容如下:", data);
  return (
    <div>
      <h2>{data.frontmatter.topic}</h2>
      <div>{data.frontmatter.description}</div>
      <div>{data.content}</div>
    </div>
  );
}
```

---

翻译这个 `https://www.bilibili.com/video/BV1PMbFezEve` 如何处理 mdx 文件，讲得很好，有水平，向他学习

- 相应源码：https://github.com/colbyfayock/my-mdx-projects
- 文字教程：https://spacejelly.dev/posts/mdx-in-nextjs

他的频道是：https://www.youtube.com/colbyfayock

- https://spacejelly.dev/nextjs

## grid 用法总结

列优先

- `grid grid-cols-3 grid-rows-2` 列数与行数同时存在，行数是没有意义，但不会报错，相当于`grid grid-cols-3`
- `grid grid-rows-2` 只有行数没有意思，不起作用
- `grid grid-cols-3 grid-flow-row` 3 列等分，从左到右，1，2，3，再另起一行 4,5,6...
- `grid grid-cols-3` 只有列数，使用默认的左右流向，上面的简写形式
- `grid grid-cols-3 grid-flow-col` 列数，流向也是列会报错
- `grid grid-rows-3 grid-flow-row` 行数，流向也是行会报错
- `grid grid-rows-3 grid-flow-col` 三行，假设有 13 个子元素，计算得，那么每行 5 个，相当于 3 行 5 列，第 1 列排 1，2，3，第 2 列排 4，5，6，第 3 列排 7，8，9，第 4 列排 10，11，12，第 5 列排 13
- 子元素，col-[2_/_span_3]，去下划线变为 `col-[2/span 3]`从第 2 列开始，占 3 列
- `grid-rows-[150px_minmax(100px,1fr)_100px] grid-flow-col` 三行，第 1 行 150px，第 2 行 100px~1fr（最小 100px 到剩余所有），第 3 行 100px，如果元素超过 3 个，计算列数，第 1 列占满后再排第 2 列
- `grid-cols-[200px_minmax(900px,_1fr)_100px]`,下划线变为空格，三列，第 1 列 200px，第 2 列 900px~1fr，第 3 列 100px，当窗口小于(200+900+100)px 时，会出现滚动条
